# 元数据验证 JSON 生成与维护策略 (Validation Strategy)

**版本**: 1.0.0
**状态**: 正式发布
**关联文档**: [元数据验证 JSON 设计规范](./metadata_validation_json_spec.md)

## 1. 策略概述

本策略文档定义了如何生成、填充、执行及维护元数据验证 JSON 文件。我们的目标是构建一个**“自动化闭环验证系统”**，将静态的 JSON 规则转化为动态的测试报告。

### 核心流程图

```mermaid
graph TD
    A[设计 JSON 模板] -->|定义规则| B(验证脚本生成器)
    B -->|生成| C[待执行 JSON (空值)]
    C -->|输入| D{自动化执行引擎}
    D -->|1. 执行 SQL| E[数据库结果]
    D -->|2. 调用 API| F[API 响应结果]
    E -->|回填| G[已填充 JSON]
    F -->|回填| G
    G -->|逻辑闭环验证| H[最终测试报告]
```

## 2. JSON 生成阶段

### 2.1 模板定义
开发人员依据《元数据验证 JSON 设计规范》，为每个模块编写基础 JSON 模板。此时所有 `实际结果` 字段均为空字符串 `""`。

**职责**:
-   **定义 SQL**: 编写能够准确统计业务指标的 SQL 语句。
-   **定义 API**: 指定与 SQL 对应的前端 API 路径及参数。
-   **定义闭环**: 在 `逻辑闭环验证` 模块中指定比对目标。

### 2.2 自动化生成
脚本 `generate_validation_json.py`（规划中）负责遍历所有模块模板，组合成全量验证文件 `full_validation_rules.json`。

## 3. 执行与填充阶段

### 3.1 SQL 执行逻辑
执行引擎遍历 JSON 中的所有 key：
-   识别以 `SQL查询` 或 `正向SQL` / `反向SQL` 结尾的字段。
-   在 `metadata.db` 上执行 SQL。
-   将执行结果（单一数值或拼接字符串）填入对应的 `SQL实际结果` 字段。

### 3.2 API 调用逻辑
执行引擎模拟前端请求：
-   识别 `API路径` 字段。
-   根据 `API统计逻辑` 对响应 JSON 进行解析和聚合（如 `COUNT`, `GROUP BY`）。
-   将聚合后的“指纹字符串”填入 `API实际结果` 字段。

### 3.3 异常处理
-   **SQL 错误**: 填入 `ERROR: <错误信息>`，并不中断后续执行。
-   **API 超时/500**: 填入 `API_FAIL: <状态码>`。

## 4. 闭环验证与报告

### 4.1 逻辑闭环检查
待所有空值填充完毕后，引擎执行 `逻辑闭环验证` 模块中的规则：
1.  解析 `前端数据源` 和 `血缘数据源` 的 JSONPath。
2.  提取两个字段的实际值。
3.  根据 `比对逻辑`（数值相等/指纹匹配）判断 Pass/Fail。

### 4.2 质量检测扫描
引擎扫描 `血缘质量检测` 模块：
-   检查是否有 SQL 返回了非零结果（针对 `IS NULL` / `NOT EXISTS` 类检查）。
-   若有，标记为 `WARNING` 或 `CRITICAL` 级别的质量缺陷。

### 4.3 报告输出
最终生成 Markdown 或 HTML 格式的测试报告，包含：
-   **概览**: 通过率、覆盖模块数。
-   **缺陷列表**: 所有校验失败的项（含预期值 vs 实际值）。
-   **质量风险**: 孤儿表、断链血缘的统计清单。

## 5. 维护与迭代

1.  **规则更新**: 当业务逻辑变更（如新增血缘关系）时，仅需更新 JSON 模板中的 SQL 和闭环规则，无需修改执行代码。
2.  **基准对齐**: 每次发版前运行全量验证，确保新旧版本验证结果的一致性。
3.  **误报治理**: 若发现 SQL 逻辑有误导致误报，修正 JSON 中的 SQL 即可即时生效。
