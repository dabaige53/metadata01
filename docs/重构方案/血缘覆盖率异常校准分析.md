# 血缘覆盖率异常校准分析报告 (51项全量版)

> **生成时间**: 2025-12-24  
> **分析对象**: `analyze_lineage.py` 生成的 51 项全量清单  
> **重要说明**: 本报告基于**代码级排查**，对比了 `analyze_lineage.py` 脚本统计口径与**前端 API 实际展示逻辑**的差异。

---

## 前后端统计口径差异说明

> [!IMPORTANT]
> `analyze_lineage.py` 使用的是**直接关联**字段 (`fields.table_id`, `fields.workbook_id`)，
> 而前端 `get_field_detail` API 使用的是**预计算推导血缘** (`field_full_lineage` 表)。
> 两者存在显著差异！

| 统计维度          | 直接关联 (脚本) | 推导关联 (前端) |    差距    |
| :---------------- | :-------------: | :-------------: | :--------: |
| **字段 → 表**     |      28.9%      |    **96.5%**    | +13,683 条 |
| **字段 → 工作簿** |      81.6%      |    **91.7%**    | +2,041 条  |

**代码出处**:
- 脚本查询: `SELECT count(*) FROM fields WHERE table_id IS NOT NULL`
- 前端查询 (api.py:2580): `SELECT ... FROM field_full_lineage fl WHERE fl.table_id IS NOT NULL`

---

## 分析标准

- ✅ **正常**: 覆盖率符合预期或因业务逻辑导致的合理波动
- ⚠️ **口径差异**: 脚本与前端统计口径不同，需注意解读
- ❌ **代码缺陷**: 需修复的技术问题

---

## 一、数据库 (1项)

### 1. 数据库 → 物理表
- **覆盖率**: 6/6 (**100.0%**)
- **血缘链路**: `数据库 → 物理表 (tables.database_id)`
- **代码验证**: 所有 6 个数据库均有物理表，`sync_databases` 正常工作。
- **结论**: ✅ **正常**

---

## 二、物理表 (5项)

### 2. 物理表 → 数据库
- **覆盖率**: 36/36 (**100.0%**)
- **血缘链路**: `物理表 → 数据库 (tables.database_id)`
- **代码验证**: `sync_tables` 中所有物理表均设置了 `database_id`。
- **结论**: ✅ **正常**

### 3. 物理表 → 数据列
- **覆盖率**: 17/36 (**47.2%**)
- **血缘链路**: `物理表 → 数据列 (db_columns.table_id)`
- **代码排查**: 查看 `sync_tables` 中 `columns` 的处理逻辑。Tableau Metadata API 对部分视图或权限受限表不返回列信息。
- **数据库验证**: 19 个物理表无列，包括 `vm_flight_history`、`ads_ord_transfer_od_break` 等。
- **结论**: ⚠️ **需关注** - 属于 Tableau API 限制，非代码缺陷。

### 4. 物理表 → 发布源
- **覆盖率**: 66/36 (**183.3%**)
- **血缘链路**: `物理表 → 发布源 (table_to_datasource)`
- **代码排查**: `sync_datasources` 中通过 `upstreamTables` 写入 `table_to_datasource`。一张表可被多个数据源引用。
- **数据库验证**: `tbl_tic_trace_ticket` 被 18 个数据源引用。
- **结论**: ✅ **正常** - 多对多关系的正常体现。

### 5. 物理表 → 嵌入源(独立)
- **覆盖率**: 108/36 (**300.0%**)
- **血缘链路**: `物理表 → 嵌入源(独立) (table_to_datasource)`
- **代码排查**: 同上，`sync_datasources` 对嵌入源也写入了 `table_to_datasource`。
- **结论**: ✅ **正常** - 多对多引用。

### 6. 物理表 → 字段
- **覆盖率**: 21/36 (**58.3%**)
- **血缘链路**: `物理表 → 字段 (fields.table_id)`
- **代码排查**: `_process_single_field` 中 `table_id` 来自 `upstreamTables[0]`。若数据源无物理表（Custom SQL），则字段无 `table_id`。
- **结论**: ✅ **正常** - Custom SQL 字段无直接物理表关联。

---

## 三、嵌入表 (4项)

### 7. 嵌入表 → 物理表
- **覆盖率**: 446/480 (**92.9%**)
- **血缘链路**: `嵌入表 → 物理表 (tables.database_id 穿透)`
- **代码排查**: `sync_tables` 中对 `is_embedded=1` 的表，通过 `database_id` 穿透到物理库。34 个 `Unknown Table` 来自 Excel/CSV。
- **结论**: ✅ **正常**

### 8. 嵌入表 → 数据列
- **覆盖率**: 180/480 (**37.5%**)
- **血缘链路**: `嵌入表 → 数据列 (db_columns.table_id)`
- **代码排查**: Custom SQL 表的列信息在 Tableau API 中无法解析，`sync_tables` 无法获取列。
- **结论**: ℹ️ **技术限制** - Tableau API 固有约束。

### 9. 嵌入表 → 嵌入源(独立)
- **覆盖率**: 108/480 (**22.5%**)
- **血缘链路**: `嵌入表 → 嵌入源(独立) (table_to_datasource)`
- **代码排查**: 穿透型嵌入源的表没有写入 `table_to_datasource`（因其表已归属上游发布源）。
- **结论**: ✅ **正常** - 符合数据分布。

### 10. 嵌入表 → 字段
- **覆盖率**: 160/480 (**33.3%**)
- **血缘链路**: `嵌入表 → 字段 (fields.table_id)`
- **代码排查**: 同第 6 项，大量嵌入表来自 Custom SQL，其字段无 `table_id`。
- **结论**: ✅ **正常**

---

## 四、数据列 (3项)

### 11. 数据列 → 物理表
- **覆盖率**: 964/5893 (**16.4%**)
- **血缘链路**: `数据列 → 物理表 (db_columns.table_id)`
- **数据库验证**: 83.6% 的列属于嵌入表（Custom SQL/Excel）。
- **结论**: ✅ **正常** - 业务数据分布。

### 12. 数据列 → 嵌入表
- **覆盖率**: 4929/5893 (**83.6%**)
- **血缘链路**: `数据列 → 嵌入表 (db_columns.table_id)`
- **结论**: ✅ **正常** - 与第 11 项互补。

### 13. 数据列 → 字段
- **覆盖率**: 4008/5893 (**68.0%**)
- **血缘链路**: `数据列 → 字段 (fields.upstream_column_id)`
- **代码排查**: `_process_single_field` 中通过 `upstreamColumns[0].id` 设置 `upstream_column_id`。1885 个列未被字段引用。
- **结论**: ✅ **正常** - 业务中存在未使用的列。

---

## 五、发布源 (4项)

### 14. 发布源 → 物理表
- **覆盖率**: 32/57 (**56.1%**)
- **血缘链路**: `发布源 → 物理表 (table_to_datasource)`
- **代码排查**: `sync_datasources` 中 `upstreamTables` 字段返回空时不写入关联。
- **数据库验证**: 6 个发布源无表关联，均为 Custom SQL（如 `融合表_周期_SQL定制数据`）。
- **结论**: ✅ **正常** - Custom SQL 无物理表是 Tableau 固有行为。

### 15. 发布源 → 嵌入源(穿透)
- **覆盖率**: 27/57 (**47.4%**)
- **血缘链路**: `发布源 → 嵌入源(穿透) (datasources.source_published_datasource_id)`
- **代码排查**: `sync_datasources` 中对穿透型嵌入源设置了 `source_published_datasource_id`。
- **结论**: ✅ **正常**

### 16. 发布源 → 工作簿
- **覆盖率**: 27/57 (**47.4%**)
- **血缘链路**: `发布源 → 工作簿 (datasource_to_workbook)`
- **代码排查**: `sync_workbooks` 中通过 `embeddedDatasources` 写入 `datasource_to_workbook`。
- **结论**: ⚠️ **需关注** - 30 个发布源未被工作簿引用，可能是孤立资产。

### 17. 发布源 → 字段
- **覆盖率**: 57/57 (**100.0%**)
- **血缘链路**: `发布源 → 字段 (fields.datasource_id)`
- **结论**: ✅ **正常**

---

## 六、嵌入源(穿透) (2项)

### 18. 嵌入源(穿透) → 发布源
- **覆盖率**: 68/68 (**100.0%**)
- **血缘链路**: `嵌入源(穿透) → 发布源 (datasources.source_published_datasource_id)`
- **代码验证**: 所有 68 个穿透型嵌入源均设置了上游发布源 ID。
- **结论**: ✅ **正常**

### 19. 嵌入源(穿透) → 工作簿
- **覆盖率**: 68/68 (**100.0%**)
- **血缘链路**: `嵌入源(穿透) → 工作簿 (datasource_to_workbook)`
- **结论**: ✅ **正常**

---

## 七、嵌入源(独立) (4项)

### 20. 嵌入源(独立) → 物理表
- **覆盖率**: 4/47 (**8.5%**)
- **血缘链路**: `嵌入源(独立) → 物理表 (table_to_datasource)`
- **代码排查**: 独立嵌入源通常是 Excel/CSV，原本就不关联数据库。
- **结论**: ✅ **正常**

### 21. 嵌入源(独立) → 嵌入表
- **覆盖率**: 40/47 (**85.1%**)
- **血缘链路**: `嵌入源(独立) → 嵌入表 (table_to_datasource)`
- **结论**: ✅ **正常**

### 22. 嵌入源(独立) → 工作簿
- **覆盖率**: 47/47 (**100.0%**)
- **血缘链路**: `嵌入源(独立) → 工作簿 (datasource_to_workbook)`
- **结论**: ✅ **正常**

### 23. 嵌入源(独立) → 字段
- **覆盖率**: 47/47 (**100.0%**)
- **血缘链路**: `嵌入源(独立) → 字段 (fields.datasource_id)`
- **结论**: ✅ **正常**

---

## 八、工作簿 (8项)

### 24. 工作簿 → 数据库
- **覆盖率**: 71/80 (**88.8%**)
- **血缘链路**: `工作簿 → 数据源 → 表 → 数据库 (穿透链路)`
- **代码排查**: 9 个工作簿完全依赖 Excel/Custom SQL，无法穿透到数据库。
- **结论**: ✅ **正常**

### 25. 工作簿 → 物理表
- **覆盖率**: 40/80 (**50.0%**)
- **血缘链路**: `工作簿 → 数据源 → 物理表 (穿透链路)`
- **代码排查**: 同上，40 个工作簿不使用物理表。
- **结论**: ✅ **正常**

### 26. 工作簿 → 嵌入表
- **覆盖率**: 57/80 (**71.2%**)
- **血缘链路**: `工作簿 → 数据源 → 嵌入表 (穿透链路)`
- **结论**: ✅ **正常**

### 27. 工作簿 → 发布源
- **覆盖率**: 47/80 (**58.8%**)
- **血缘链路**: `工作簿 → 发布源 (datasource_to_workbook)`
- **结论**: ✅ **正常**

### 28. 工作簿 → 嵌入源(穿透)
- **覆盖率**: 47/80 (**58.8%**)
- **血缘链路**: `工作簿 → 嵌入源(穿透) (datasource_to_workbook)`
- **结论**: ✅ **正常**

### 29. 工作簿 → 嵌入源(独立)
- **覆盖率**: 35/80 (**43.8%**)
- **血缘链路**: `工作簿 → 嵌入源(独立) (datasource_to_workbook)`
- **结论**: ✅ **正常**

### 30. 工作簿 → 视图
- **覆盖率**: 80/80 (**100.0%**)
- **血缘链路**: `工作簿 → 视图 (views.workbook_id)`
- **结论**: ✅ **正常**

### 31. 工作簿 → 字段
- **覆盖率**: 80/80 (**100.0%**)
- **血缘链路**: `工作簿 → 字段 (fields.workbook_id)`
- **代码验证**: 本次修复的核心成果，所有工作簿均有关联字段。
- **结论**: ✅ **正常** ⭐

---

## 九、视图 (4项)

### 32. 视图 → 数据库
- **覆盖率**: 517/1595 (**32.4%**)
- **血缘链路**: `视图 → 字段 → 表 → 数据库 (穿透链路)`
- **代码排查**: 依赖 `field_to_view` 和 `fields.table_id` 穿透。大量视图的字段无 `table_id`。
- **结论**: ⚠️ **口径差异** - 前端使用 `field_full_lineage` 可达更高覆盖率。

### 33. 视图 → 物理表
- **覆盖率**: 47/1595 (**2.9%**)
- **血缘链路**: `视图 → 字段 → 物理表 (穿透链路)`
- **代码排查**: 仅 47 个视图的字段直接关联物理表。但 506 个视图关联嵌入表。
- **前端验证**: 前端通过 `field_full_lineage` 展示，覆盖率更高。
- **结论**: ⚠️ **口径差异** - **脚本统计的是直接关联，前端展示的是推导关联**。

### 34. 视图 → 工作簿
- **覆盖率**: 1595/1595 (**100.0%**)
- **血缘链路**: `视图 → 工作簿 (views.workbook_id)`
- **结论**: ✅ **正常**

### 35. 视图 → 字段
- **覆盖率**: 1389/1595 (**87.1%**)
- **血缘链路**: `视图 → 字段 (field_to_view)`
- **代码排查**: 206 个视图无关联字段，可能是空白视图或导航页。
- **结论**: ✅ **正常**

---

## 十、字段 (10项)

### 36. 字段 → 数据库
- **覆盖率**: 4599/20231 (**22.7%**)
- **血缘链路**: `字段 → 表 → 数据库 (穿透链路)`
- **代码排查**: 依赖 `fields.table_id`。71.1% 的字段无 `table_id`。
- **前端验证**: 前端通过 `field_full_lineage` 展示，覆盖率达 **96.5%** (19521/20231)。
- **结论**: ⚠️ **口径差异** - 脚本 22.7% vs 前端 96.5%

### 37. 字段 → 物理表
- **覆盖率**: 1501/20231 (**7.4%**)
- **血缘链路**: `字段 → 物理表 (fields.table_id)`
- **代码排查**: 直接关联率低。
- **前端验证**: 前端通过 `field_full_lineage.table_id` 推导，覆盖率高得多。
- **结论**: ⚠️ **口径差异** - 这是最大的统计口径差异点。

### 38. 字段 → 嵌入表
- **覆盖率**: 4337/20231 (**21.4%**)
- **血缘链路**: `字段 → 嵌入表 (fields.table_id)`
- **结论**: ✅ **正常**

### 39. 字段 → 数据列
- **覆盖率**: 4658/15298 (**30.4%**)
- **血缘链路**: `字段 → 数据列 (fields.upstream_column_id)`
- **代码排查**: 仅非计算字段参与统计。Custom SQL 字段无 `upstream_column_id`。
- **结论**: ✅ **正常**

### 40. 字段 → 发布源
- **覆盖率**: 15597/20231 (**77.1%**)
- **血缘链路**: `字段 → 发布源 (fields.datasource_id)`
- **结论**: ✅ **正常**

### 41. 字段 → 嵌入源(穿透)
- **覆盖率**: 0/20231 (**0.0%**)
- **血缘链路**: `字段 → 嵌入源(穿透) (fields.datasource_id)`
- **代码排查**: 这是"Hybrid Mode"去重策略的**预期结果**。所有穿透型嵌入源的字段已被强制重映射到上游发布源。
- **代码出处**: `tableau_sync.py` `sync_fields` 第 1920 行左右。
- **结论**: ✅ **符合设计预期**

### 42. 字段 → 嵌入源(独立)
- **覆盖率**: 4634/20231 (**22.9%**)
- **血缘链路**: `字段 → 嵌入源(独立) (fields.datasource_id)`
- **结论**: ✅ **正常**

### 43. 字段 → 工作簿
- **覆盖率**: 16513/20231 (**81.6%**)
- **血缘链路**:
  - `字段 → 工作簿 (fields.workbook_id)`
  - `字段 → 数据源 → 工作簿 (穿透链路)`
- **前端验证**: 前端通过 `field_full_lineage.workbook_id` 展示，覆盖率达 **91.7%**。
- **结论**: ⚠️ **口径差异** - 脚本 81.6% vs 前端 91.7%

### 44. 字段 → 视图
- **覆盖率**: 3063/20231 (**15.1%**)
- **血缘链路**: `字段 → 视图 (field_to_view)`
- **代码排查**: 大量字段存在于数据源中但未被视图实际使用。
- **结论**: ✅ **正常**

### 45. 字段 → 计算字段
- **覆盖率**: 1938/20231 (**9.6%**)
- **血缘链路**: `字段 → 计算字段 (field_dependencies, 被计算字段依赖)`
- **结论**: ✅ **正常**

---

## 十一、计算字段 (6项)

### 46. 计算字段 → 物理表
- **覆盖率**: 1122/4933 (**22.7%**)
- **血缘链路**:
  - `计算字段 → 物理表 (fields.table_id, 直接关联)`
  - `计算字段 → 依赖字段 → 物理表 (递归穿透)`
- **代码排查**: 直接关联率低，但通过 `field_full_lineage` 推导后达 **95.2%** (4697/4933)。
- **代码出处**: `_compute_full_lineage` 方法负责预计算。
- **结论**: ⚠️ **口径差异** - 脚本 22.7% vs 推导 95.2%

### 47. 计算字段 → 字段(依赖)
- **覆盖率**: 4857/4933 (**98.5%**)
- **血缘链路**: `计算字段 → 依赖字段 (field_dependencies.dependency_field_id)`
- **代码验证**: `sync_lineage` 中公式解析逻辑几乎完美覆盖。
- **结论**: ✅ **正常**

### 48. 计算字段 → 发布源
- **覆盖率**: 3631/4933 (**73.6%**)
- **血缘链路**: `计算字段 → 发布源 (fields.datasource_id)`
- **结论**: ✅ **正常**

### 49. 计算字段 → 嵌入源(独立)
- **覆盖率**: 1302/4933 (**26.4%**)
- **血缘链路**: `计算字段 → 嵌入源(独立) (fields.datasource_id)`
- **代码验证**: 73.6% + 26.4% = 100%，全量覆盖。
- **结论**: ✅ **正常**

### 50. 计算字段 → 工作簿
- **覆盖率**: 4932/4933 (**100.0%**)
- **血缘链路**:
  - `计算字段 → 工作簿 (fields.workbook_id)`
  - `计算字段 → 数据源 → 工作簿 (穿透链路)`
- **代码验证**: **本次修复的核心成果**。`sync_fields` 和 `_process_single_field` 已正确设置 `workbook_id`。
- **结论**: ✅ **正常** ⭐

### 51. 计算字段 → 视图
- **覆盖率**: 1710/4933 (**34.7%**)
- **血缘链路**: `计算字段 → 视图 (field_to_view)`
- **代码排查**: 大量计算字段未被视图直接使用，可能是备用指标或中间计算。
- **结论**: ✅ **正常**

---

## 总结

| 类别         | 检查项数 |  正常  | 口径差异 | 需关注 | 代码缺陷 |
| :----------- | :------: | :----: | :------: | :----: | :------: |
| 数据库       |    1     |   1    |    0     |   0    |    0     |
| 物理表       |    5     |   4    |    0     |   1    |    0     |
| 嵌入表       |    4     |   4    |    0     |   0    |    0     |
| 数据列       |    3     |   3    |    0     |   0    |    0     |
| 发布源       |    4     |   3    |    0     |   1    |    0     |
| 嵌入源(穿透) |    2     |   2    |    0     |   0    |    0     |
| 嵌入源(独立) |    4     |   4    |    0     |   0    |    0     |
| 工作簿       |    8     |   8    |    0     |   0    |    0     |
| 视图         |    4     |   2    |    2     |   0    |    0     |
| 字段         |    10    |   7    |    3     |   0    |    0     |
| 计算字段     |    6     |   5    |    1     |   0    |    0     |
| **合计**     |  **51**  | **43** |  **6**   | **2**  |  **0**   |

---

## 核心结论

1. **51 项血缘检查中，未发现任何代码缺陷 (0 项)**。
2. **6 项存在统计口径差异**：`analyze_lineage.py` 使用直接关联 (`fields.table_id`)，前端 API 使用推导关联 (`field_full_lineage`)。前端展示的覆盖率更高、更准确。
3. **2 项需关注**：
   - 第 3 项：部分物理表无列信息 (Tableau API 限制)
   - 第 16 项：30 个发布数据源未被工作簿引用 (可能是孤立资产)
4. **Custom SQL 是覆盖率缺损的主要原因**：系统中约 40% 的数据来自 Custom SQL，这些数据在 Tableau API 层面是黑盒，无法解析物理表/列信息。
