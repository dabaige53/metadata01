# 元数据采集、存储与血缘关联完整说明（产品视角）

> 本文档详细介绍系统中每个元数据模块的采集方式、存储结构、血缘建立过程、如何查找其他元素、以及相关的问题和解决方案。文档按照数据流向顺序，逐个模块详细展开。

---

# 第一部分：总体概述

## 一、系统架构

### 1.1 数据来源
系统通过两个 API 从 Tableau 服务器获取元数据：
- **Metadata API (GraphQL)**：获取详细的元数据和血缘关系
- **REST API**：获取资产基本信息和访问统计

### 1.2 同步顺序
系统按照以下固定顺序依次采集，确保上游元素先入库，下游元素可正确关联：

```
用户 → 项目 → 数据库 → 数据表(含原始列) → 数据源 → 工作簿(含嵌入式数据源、视图) → 字段 → 视图字段使用关系 → 血缘关系
```

### 1.3 血缘记录方式
系统通过两种方式记录血缘：

| 方式           | 说明                            | 示例                                             |
| -------------- | ------------------------------- | ------------------------------------------------ |
| **直接记录**   | 在元素上直接保存"它属于谁"的 ID | 字段保存 `datasource_id` 指向所属数据源          |
| **关联表记录** | 用单独的表存储"谁和谁有关系"    | `table_to_datasource` 表记录"表被哪个数据源引用" |

为什么需要关联表？因为有些关系是**多对多**的，无法用单个字段记录。

---

## 二、数据库表结构

### 2.1 主表（存储元素本身）

| 表名                | 存储内容     | 关键关联字段                                                     |
| ------------------- | ------------ | ---------------------------------------------------------------- |
| `databases`         | 数据库       | 无（最上游）                                                     |
| `tables`            | 数据表       | `database_id` 指向所属数据库                                     |
| `db_columns`        | 原始列       | `table_id` 指向所属数据表                                        |
| `datasources`       | 数据源       | `source_published_datasource_id`（嵌入式指向上游发布源）         |
| `fields`            | 字段         | `datasource_id`、`table_id`、`workbook_id`、`upstream_column_id` |
| `workbooks`         | 工作簿       | 无直接关联字段                                                   |
| `views`             | 视图         | `workbook_id` 指向所属工作簿                                     |
| `calculated_fields` | 计算字段详情 | `field_id` 指向字段                                              |

### 2.2 关联表（存储多对多关系）

| 关联表名                 | 记录什么关系           | 字段说明                                                  |
| ------------------------ | ---------------------- | --------------------------------------------------------- |
| `table_to_datasource`    | 数据表 ↔ 数据源        | `table_id` + `datasource_id`                              |
| `datasource_to_workbook` | 数据源 ↔ 工作簿        | `datasource_id` + `workbook_id`                           |
| `field_to_view`          | 字段 ↔ 视图            | `field_id` + `view_id`                                    |
| `dashboard_to_sheet`     | 仪表板 ↔ 图表          | `dashboard_id` + `sheet_id`                               |
| `field_dependencies`     | 计算字段 → 依赖字段    | `source_field_id` + `dependency_field_id`                 |
| `field_full_lineage`     | 字段完整血缘（预计算） | `field_id` + `table_id` + `datasource_id` + `workbook_id` |

---

# 第二部分：各模块详解

---

## 模块一：数据库

### 1. 基本概念

**业务含义**：数据库是最底层的数据来源，代表一个物理数据库连接，比如公司的 Snowflake 数据仓库、Oracle 数据库等。

**在血缘中的位置**：最上游，是整个血缘链的起点。

---

### 2. 采集过程

**从哪里获取**：调用 Tableau 的数据库服务器列表接口。

**调用的接口**：GraphQL 查询 `databaseServers` 节点。

**获取的信息**：
- 数据库唯一标识（ID）
- 数据库名称
- 连接类型（Snowflake、Oracle、SQL Server、Excel 等）
- 主机地址、端口
- 是否认证
- 认证说明

---

### 3. 存储方式

**存入表**：`databases`

**存储过程**：
```
遍历 Tableau 返回的数据库列表：
   ↓
对每个数据库：
   检查数据库中是否已存在该 ID 的记录
   ↓
   ├─ 存在：更新记录
   └─ 不存在：新增记录
   ↓
保存以下字段：
   id = 数据库唯一标识
   name = 数据库名称
   connection_type = 连接类型
   host_name = 主机地址
   port = 端口号
   is_certified = 是否认证
```

---

### 4. 血缘建立

数据库是最上游的元素，**不需要主动建立上游血缘**。

下游元素（数据表）会在同步时主动设置 `database_id` 指向数据库，从而建立关联。

---

### 5. 如何找到其他元素

#### 5.1 如何找到数据表？

**查找逻辑**：在 `tables` 表中，查找所有 `database_id = 当前数据库ID` 的记录。

**产品理解**：因为每张表在存储时都记录了"我属于哪个数据库"（设置了 `database_id` 字段），所以反过来查就能知道"这个数据库有哪些表"。

**SQL 示例**：
```sql
SELECT * FROM tables WHERE database_id = '当前数据库ID'
```

#### 5.2 如何找到数据源？

**查找逻辑**：
1. 先找到本数据库的所有数据表（方法如上）
2. 拿这些表的 ID，去 `table_to_datasource` 关联表查找
3. 找到所有关联的 `datasource_id`

**产品理解**：数据源同步时会记录"我引用了哪些表"（插入 `table_to_datasource` 记录），所以可以反向查"这些表被哪些数据源引用"。

**SQL 示例**：
```sql
SELECT DISTINCT td.datasource_id 
FROM tables t
JOIN table_to_datasource td ON t.id = td.table_id
WHERE t.database_id = '当前数据库ID'
```

#### 5.3 如何找到工作簿？

**查找逻辑**：
1. 先找到数据源（方法如上）
2. 拿数据源 ID，去 `datasource_to_workbook` 关联表查找
3. 找到所有关联的 `workbook_id`

**SQL 示例**：
```sql
SELECT DISTINCT dw.workbook_id
FROM tables t
JOIN table_to_datasource td ON t.id = td.table_id
JOIN datasource_to_workbook dw ON td.datasource_id = dw.datasource_id
WHERE t.database_id = '当前数据库ID'
```

#### 5.4 如何找到字段？

**查找逻辑**：
1. 先找到数据表
2. 在 `fields` 表中查找 `table_id` 在这些表中的记录

---

### 6. 相关问题

数据库模块相对简单，**没有特殊问题**。

---

## 模块二：数据表

### 1. 基本概念

**业务含义**：数据表是数据库中的具体表或视图，比如"订单表"、"用户表"。它是物理层与逻辑层（数据源）的桥梁。

**在血缘中的位置**：上游是数据库，下游是数据源和字段。

---

### 2. 采集过程

**从哪里获取**：调用 Tableau 的数据库表列表接口。

**调用的接口**：GraphQL 查询 `databaseTables` 节点。

**获取的信息**：
- 表唯一标识（ID）
- 表名称、Schema（数据库分区）
- 所属数据库的标识
- 是否是嵌入式表
- 是否认证
- **表包含的所有原始列**（嵌套在一起获取）

---

### 3. 存储方式

**存入表**：`tables`（表本身）、`db_columns`（原始列）

**存储过程**：
```
遍历 Tableau 返回的数据表列表：
   ↓
对每张表：
   检查是否已存在该 ID 的记录
   ↓
   ├─ 存在：更新记录
   └─ 不存在：新增记录
   ↓
保存以下字段：
   id = 表唯一标识
   name = 表名称
   schema = 所属 Schema
   database_id = 所属数据库的 ID  ← 这里建立了与数据库的关联
   is_embedded = 是否嵌入式表
   ↓
同时处理该表包含的原始列：
   遍历 columns 列表：
      对每列，保存到 db_columns 表：
         id = 列唯一标识
         name = 列名
         remote_type = 数据库原生类型（如 VARCHAR(255)）
         table_id = 当前表的 ID  ← 这里建立了列与表的关联
```

---

### 4. 血缘建立

#### 4.1 表 → 数据库

**建立方式**：直接在表记录上设置 `database_id = 数据库的ID`。

**建立时机**：在保存数据表时。

**数据来源**：Tableau 返回的表信息中包含 `database.id` 字段。

#### 4.2 列 → 表

**建立方式**：直接在列记录上设置 `table_id = 表的ID`。

**建立时机**：在保存数据表时同步保存列。

---

### 5. 如何找到其他元素

#### 5.1 如何找到数据库？

**查找逻辑**：直接读取本表的 `database_id` 字段，用这个 ID 去 `databases` 表查询。

**产品理解**：表在存储时就记录了"我属于哪个数据库"，直接读取就行。

#### 5.2 如何找到原始列？

**查找逻辑**：在 `db_columns` 表中，查找所有 `table_id = 当前表ID` 的记录。

#### 5.3 如何找到数据源？

**查找逻辑**：在 `table_to_datasource` 关联表中，查找所有 `table_id = 当前表ID` 的记录，得到 `datasource_id` 列表。

**血缘建立时机**：这条关联记录是在**数据源同步时**插入的（不是在表同步时）。

#### 5.4 如何找到字段？

**方式一**：直接查 `fields` 表中 `table_id = 当前表ID` 的记录。

**方式二**：查 `field_full_lineage` 预计算表。

**血缘建立时机**：这个关联是在**字段同步时**建立的。字段同步时，系统解析字段的 `upstreamColumns`（上游原始列），从中提取表 ID，设置到字段的 `table_id` 字段。

#### 5.5 如何找到工作簿？

**查找逻辑**：
1. 先找到引用本表的数据源（通过 `table_to_datasource`）
2. 再找到使用这些数据源的工作簿（通过 `datasource_to_workbook`）

---

### 6. 相关问题

#### 问题一：嵌入式表详解

##### 什么是嵌入式表？

嵌入式表是 Tableau 内部定义的一种"虚拟表"，它不是数据库中真实存在的物理表，而是存在于数据源内部的表定义。

**产生来源**：
1. **Excel/CSV 导入**：用户将 Excel 文件拖入 Tableau 时，会创建嵌入式表
2. **自定义 SQL**：用户编写 SQL 语句创建的结果集，在 Tableau 中表现为 CustomSQLTable
3. **数据混合**：多表 JOIN 后的结果集
4. **虚拟连接表**：VirtualConnectionTable 类型

**识别方式**：Tableau API 返回的表信息中 `isEmbedded = true` 或 `__typename` 为 `EmbeddedTable`、`CustomSQLTable`、`VirtualConnectionTable`。

##### 嵌入式表与物理表的关系

嵌入式表虽然不是真正的物理表，但它通常"来源于"某些物理表。这个来源关系通过 `upstreamTables` 字段记录。

**关系图示**：
```
物理表（DatabaseTable）
   ↑ 是...的上游
   |
嵌入式表（EmbeddedTable / CustomSQLTable）
   ↑ 字段引用
   |
字段（Field.upstream_column_id 指向嵌入式表的列）
```

**举例说明**：
- 用户在数据源中写了一个 SQL：`SELECT * FROM 订单表 WHERE 年份 = 2024`
- 这会生成一个 CustomSQLTable，它的 `upstreamTables` 包含"订单表"
- 字段的 `upstream_column_id` 会指向 CustomSQLTable 中的列
- 但我们真正关心的是字段来自哪张物理表（订单表）

##### 血缘穿透逻辑

**问题**：字段的 `upstream_column_id` 可能指向嵌入式表的列，但我们希望血缘能追溯到真正的物理表。

**解决方案**：在字段同步时，如果发现关联的是嵌入式表，就"穿透"到它的上游物理表。

**穿透过程**：
```
处理字段的 upstreamColumns 时：
   ↓
取第一个列，获取其所属的 table 信息
   ↓
检查 table.__typename（表类型）：
   ↓
├─ DatabaseTable（物理表）：
│    这是我们要的！直接使用其 ID
│    设置 field.table_id = table.id
│
├─ EmbeddedTable / CustomSQLTable（嵌入式/自定义 SQL）：
│    ↓
│    读取 table.upstreamTables 列表（嵌入式表的上游物理表）
│    ↓
│    ├─ 不为空：取第一个上游表的 ID
│    │    设置 field.table_id = upstreamTables[0].id
│    │
│    └─ 为空：无法穿透，只能使用嵌入式表的 ID
│         设置 field.table_id = table.id（血缘不完整）
│
└─ VirtualConnectionTable（虚拟连接表）：
     同上处理，但更容易穿透失败
```

**代码逻辑示例**：
```python
def _get_physical_table_id(self, table_info):
    typename = table_info.get("__typename")
    
    if typename == "DatabaseTable":
        # 物理表，直接使用
        return table_info.get("id")
    
    # 嵌入式表或 Custom SQL 表，尝试穿透到 upstreamTables
    upstream_tables = table_info.get("upstreamTables") or []
    if upstream_tables:
        return upstream_tables[0].get("id")
    
    # 无法穿透，返回原 ID（后续会标记为异常）
    return table_info.get("id")
```

##### 处理方式

系统会保存嵌入式表到 `tables` 表中，并标记 `is_embedded = 1`，原因：
1. 字段的 `upstream_column_id` 可能引用嵌入式表的列，需要有记录才能关联
2. 便于前端展示"嵌入式"标签，让用户知道这不是物理表
3. 保留完整的元数据信息

---

#### 问题二：嵌入式表到工作簿关联缺失（已修复）

**问题现象**：嵌入式表详情页显示"引用工作簿: 0"，但它明明来自某个工作簿。

**产生原因**：
在处理"穿透型嵌入源"时，系统的处理流程是：
1. 识别嵌入源有上游发布源
2. 将上游发布源关联到工作簿 ✅
3. 保存嵌入式数据源记录 ✅
4. **遗漏了**：将嵌入式数据源本身也关联到工作簿 ❌

因为遗漏了第 4 步，导致：
- 嵌入式数据源虽然存在于 `datasources` 表
- 但 `datasource_to_workbook` 表中没有它的记录
- 反向查询"这个嵌入式数据源被哪些工作簿使用"时，结果为空
- 进一步导致嵌入式表（通过 `table_to_datasource` 关联到嵌入式数据源）也查不到工作簿

**解决方案**：
在保存穿透型嵌入式数据源后，显式调用建立工作簿关联：
```python
# 原代码只做了：
self._save_embedded_datasource(eds, wb_data["id"], source_published_ds_id=upstream_ds_id)

# 修复后增加：
self._link_datasource_to_workbook(eds["id"], wb_data["id"])  # 补齐这一步
```

---

#### 问题三：嵌入式表列 ID 无法匹配（部分无法解决）

**问题现象**：
部分字段的 `upstream_column_id` 在 `db_columns` 表中找不到对应记录，导致"三层命名"（字段名→物理列名→表名）不完整。

**产生原因及分类**：

| 类型                      | 能否解决     | 说明                                     |
| ------------------------- | ------------ | ---------------------------------------- |
| EmbeddedTable 列          | ✅ 可穿透     | 通过 upstreamTables 穿透到物理表         |
| CustomSQLTable 列         | ⚠️ 部分可穿透 | 取决于 Tableau 是否解析出 upstreamTables |
| VirtualConnectionTable 列 | ❌ 无法穿透   | Tableau 不返回 upstreamTables            |
| 计算字段生成的列          | ❌ 无依赖     | 这类列没有物理来源                       |

**处理策略**：
1. **能穿透的**：使用穿透后的物理表 ID
2. **无法穿透的**：
   - 保留原始的嵌入式表 ID 作为 `table_id`
   - 在前端标记"来源不完整"
   - 在验证报告中记录为 WARN

**验证指标**：
- 修复前（不穿透）：三层命名覆盖率 10.7%
- 修复后（穿透）：三层命名覆盖率 41.4%
- 剩余 1,567 个字段无法建立完整血缘

---

## 模块三：原始列

### 1. 基本概念

**业务含义**：原始列是数据表中的具体字段，是数据库里的真实物理列，代表数据的最小物理单元。

**在血缘中的位置**：上游是数据表，下游是 Tableau 字段。

---

### 2. 采集过程

**采集时机**：在数据表同步时一起获取（嵌套在表信息中）。

**获取的信息**：
- 列唯一标识
- 列名称
- 数据库原生数据类型（如 VARCHAR(255)、NUMBER(18,2)）
- 是否允许为空

---

### 3. 存储方式

**存入表**：`db_columns`

**关键字段**：`table_id` 指向所属数据表。

---

### 4. 血缘建立

**列 → 表**：存储时直接设置 `table_id`。

---

### 5. 如何找到其他元素

#### 5.1 如何找到数据表？

**查找逻辑**：直接读取本列的 `table_id` 字段。

#### 5.2 如何找到数据库？

**查找逻辑**：先找到数据表（读取 `table_id`），再读取表的 `database_id`。

#### 5.3 如何找到对应的 Tableau 字段？

**查找逻辑**：在 `fields` 表中，查找所有 `upstream_column_id = 当前列ID` 的记录。

**产品理解**：字段在保存时记录了"我对应数据库的哪一列"（`upstream_column_id`），反过来查就能知道"这列被哪些字段使用"。

---

### 6. 相关问题

#### 问题一：部分列 ID 无法匹配

**问题现象**：1,567 个字段的 `upstream_column_id` 无法在 `db_columns` 表中找到对应记录。

**产生原因**：这些列来自 VirtualConnectionTable 或 CustomSQLTable，它们不是物理表，其列不会被同步到 `db_columns`。

**影响**：这些字段无法建立完整的三层命名（字段名→物理列名→表名）。

**状态**：无法解决，标记为 WARN。

---

## 模块四：数据源

### 1. 基本概念

**业务含义**：数据源是 Tableau 的"语义层"，是连接数据库和报表之间的桥梁。数据源对原始表进行加工、关联、重命名，供报表人员使用。

**在血缘中的位置**：上游是数据表，下游是工作簿和字段。

**分类**：
- **已发布数据源**：独立发布到服务器上，可被多个工作簿共享复用
- **嵌入式数据源**：直接嵌在工作簿里面，不独立存在

---

### 2. 采集过程

#### 2.1 已发布数据源

**从哪里获取**：调用 Tableau 的已发布数据源列表接口。

**调用的接口**：GraphQL 查询 `publishedDatasources` 节点。

**获取的信息**：
- 数据源唯一标识
- 名称、项目、所有者
- 是提取还是实时连接
- 最后刷新时间
- 是否认证、认证说明
- **上游表列表**（`upstreamTables`）← 这是建立 `table_to_datasource` 的关键

#### 2.2 嵌入式数据源

**采集时机**：在工作簿同步时处理。

**获取方式**：从工作簿详情中的 `embeddedDatasources` 字段获取。

---

### 3. 存储方式

**存入表**：`datasources`

**关键字段**：
- `is_embedded`：标记是否嵌入式
- `source_published_datasource_id`：如果是穿透型嵌入源，指向上游的已发布数据源

---

### 4. 血缘建立

#### 4.1 `table_to_datasource` 关联表的建立

这是理解数据源血缘的关键！

**建立时机**：在**数据源同步**时建立。

**数据来源**：Tableau API 返回的 `upstreamTables` 字段列表。

**详细过程**：
```
同步数据源时：
   ↓
读取数据源详情，获取 upstreamTables 列表
   ↓
例如返回：[
   {"id": "table-001", "name": "订单表"},
   {"id": "table-002", "name": "用户表"}
]
   ↓
对每张上游表：
   ↓
   检查 table_to_datasource 表中是否已存在这条关联
   SELECT * FROM table_to_datasource 
   WHERE table_id = 'table-001' AND datasource_id = 'ds-001'
   ↓
   ├─ 存在：跳过
   └─ 不存在：插入关联记录
      INSERT INTO table_to_datasource (table_id, datasource_id, relationship_type)
      VALUES ('table-001', 'ds-001', 'upstream')
```

**产品理解**：Tableau 告诉我们"这个数据源引用了哪些表"，系统把这个关系记录到 `table_to_datasource` 表中。之后就能反向查询"这张表被哪些数据源引用"。

#### 4.2 嵌入式数据源的特殊处理

嵌入式数据源根据是否有上游发布源，分为两种情况：

| 类型           | 判断条件                 | 处理方式                                             |
| -------------- | ------------------------ | ---------------------------------------------------- |
| **穿透型**     | 有 `upstreamDatasources` | 设置 `source_published_datasource_id = 上游发布源ID` |
| **独立直连型** | 无 `upstreamDatasources` | 保存为独立实体，建立到上游表的关联                   |

**穿透型处理详细过程**：
```
处理工作簿的嵌入式数据源时：
   ↓
检查该嵌入源的 upstreamDatasources 列表
   ↓
如果不为空（有上游发布源）：
   ↓
   这是"穿透型"嵌入源
   ↓
   1. 将上游发布源关联到工作簿
      INSERT INTO datasource_to_workbook (datasource_id, workbook_id)
      VALUES ('published-ds-001', 'wb-001')
   ↓
   2. 保存嵌入式数据源记录到 datasources 表
      设置 source_published_datasource_id = 'published-ds-001'
   ↓
   3. 将嵌入式数据源本身也关联到工作簿
      INSERT INTO datasource_to_workbook (datasource_id, workbook_id)
      VALUES ('embedded-ds-001', 'wb-001')
```

**独立直连型处理详细过程**：
```
如果 upstreamDatasources 为空：
   ↓
   这是"独立直连型"嵌入源（直接连数据库，没有发布）
   ↓
   1. 保存为独立实体到 datasources 表
      设置 is_embedded = 1
      设置 project_name = '(Embedded)'
   ↓
   2. 建立到上游表的关联（从 upstreamTables 获取）
      遍历 eds.upstreamTables：
         INSERT INTO table_to_datasource (table_id, datasource_id)
         VALUES ('table-id', 'embedded-ds-001')
   ↓
   3. 建立到工作簿的关联
      INSERT INTO datasource_to_workbook (datasource_id, workbook_id)
      VALUES ('embedded-ds-001', 'wb-001')
```

#### 4.3 穿透型与独立直连型的详细对比

##### 4.3.1 核心区别

| 特性                                 | **穿透型嵌入源**                      | **独立直连型嵌入源**                  |
| ------------------------------------ | ------------------------------------- | ------------------------------------- |
| **判断条件**                         | 有 `upstreamDatasources`              | 无 `upstreamDatasources`              |
| **业务含义**                         | 引用了已发布数据源的"副本"            | 直接连接数据库（如拖入 Excel）        |
| **与发布源的关系**                   | 有上游依赖，字段穿透到已发布源        | 无上游依赖，自己就是数据源头          |
| **`source_published_datasource_id`** | 设置为上游发布源 ID                   | 为空（NULL）                          |
| **字段归属**                         | 字段的 `datasource_id` 指向上游发布源 | 字段的 `datasource_id` 指向嵌入源自身 |

##### 4.3.2 穿透型的产生场景

```
用户在工作簿中"连接"一个已发布数据源"销售数据"
   ↓
Tableau 自动生成一个嵌入式数据源作为"副本"
   ↓
这个嵌入源的 upstreamDatasources = ["销售数据"]
   ↓
目的：允许工作簿对发布源做本地修改（如改别名、加计算字段），而不影响发布源本身
```

##### 4.3.3 独立直连型的产生场景

```
用户在工作簿中直接拖入一个 Excel 文件
   ↓
Tableau 生成一个嵌入式数据源
   ↓
这个嵌入源没有 upstreamDatasources（它不引用任何已发布源）
   ↓
这是一个独立的数据源，必须保存否则血缘断裂
```

##### 4.3.4 血缘路径对比

**穿透型血缘路径**：
```
物理表 (DatabaseTable)
    │
    │ table_to_datasource (在发布源同步时建立)
    ▼
已发布数据源 (Published DS)  ◄──────────────┐
    │                                        │ source_published_datasource_id
    │ upstreamDatasources                    │
    ▼                                        │
嵌入式数据源 (Embedded DS) ──────────────────┘
    │
    │ datasource_to_workbook
    ▼
工作簿 (Workbook)
```

**关键点**：
- 穿透型嵌入式数据源 **不直接关联物理表**
- 物理表的关联在 **已发布数据源** 层建立（`table_to_datasource`）
- 嵌入式数据源通过 `source_published_datasource_id` **穿透**到发布源
- 要追溯物理表，需要：嵌入源 → 发布源 → `table_to_datasource` → 物理表

**独立直连型血缘路径**：
```
物理表 (DatabaseTable)       或      嵌入表 (EmbeddedTable/CustomSQLTable)
    │                                     │
    │ table_to_datasource                 │ table_to_datasource
    │ (从 upstreamTables 获取)            │ (如果没有物理表穿透)
    ▼                                     ▼
嵌入式数据源 (Embedded DS, is_embedded=1)
    │
    │ datasource_to_workbook
    ▼
工作簿 (Workbook)
```

**关键点**：
- 独立直连型嵌入式数据源 **直接建立** `table_to_datasource` 关联
- 关联的表类型取决于 Tableau API 返回的 `upstreamTables`：
  - 如果是 `DatabaseTable` → 直接关联物理表 ✅
  - 如果是 `EmbeddedTable`/`CustomSQLTable` → 关联嵌入表，需要进一步穿透

##### 4.3.5 与物理表/嵌入表的关系总结

| 类型           | 首先连接的是                          | 与物理表的关系                | `table_to_datasource` 建立位置 |
| -------------- | ------------------------------------- | ----------------------------- | ------------------------------ |
| **穿透型**     | 已发布数据源（非物理表）              | 间接（通过发布源）            | 在发布源层                     |
| **独立直连型** | 物理表或嵌入表（取决于 Tableau 返回） | 直接（通过 `upstreamTables`） | 在嵌入源层                     |

**两者都能追溯到物理表**，只是路径不同。独立直连型是直接关联，穿透型需要多跳一步。

#### 4.4 嵌入表穿透逻辑详解

##### 4.4.1 什么是"嵌入表穿透"？

穿透是指：当我们遇到一个**嵌入式表**（如 `EmbeddedTable`、`CustomSQLTable`）时，试图找到它**背后的物理表**（`DatabaseTable`），从而建立完整的血缘链路。

##### 4.4.2 穿透判断流程

```
字段的 upstreamColumns[0].table
    │
    ├── __typename = "DatabaseTable"
    │       ↓
    │   直接使用该表 ID (无需穿透) ✅
    │
    ├── __typename = "EmbeddedTable" / "CustomSQLTable"
    │       ↓
    │   检查 table.upstreamTables
    │       ↓
    │   ├── 有值 → 取 upstreamTables[0].id (穿透成功) ✅
    │   └── 空/无 → 使用原嵌入表 ID (穿透失败) ❌
    │
    └── __typename = "VirtualConnectionTable"
            ↓
        通常无法穿透 (Tableau 不返回 upstreamTables) ❌
```

##### 4.4.3 不同表类型的穿透能力

| 表类型                     | 能否穿透     | 说明                                                  |
| -------------------------- | ------------ | ----------------------------------------------------- |
| **EmbeddedTable**          | ✅ 通常可穿透 | Tableau 知道来源于哪张物理表，会返回 `upstreamTables` |
| **CustomSQLTable**         | ⚠️ 部分可穿透 | 取决于 SQL 复杂度，简单 SQL 能解析出物理表            |
| **VirtualConnectionTable** | ❌ 无法穿透   | Tableau 设计上不暴露虚拟连接的底层物理表              |
| **计算生成的列**           | ❌ 无需穿透   | 这类数据没有物理来源                                  |

##### 4.4.4 穿透失败的根本原因

**穿透失败的本质**：Tableau Metadata API **没有返回** `upstreamTables` 字段，或者返回的是**空数组**。

**具体原因分类**：

| 失败类型                 | 原因描述                                                        | 是否可解决               |
| ------------------------ | --------------------------------------------------------------- | ------------------------ |
| **Tableau 无法解析 SQL** | 复杂 SQL、动态表名、存储过程调用等无法被 Tableau SQL 解析器识别 | ❌ 无法解决               |
| **Tableau 设计不暴露**   | 虚拟连接等高级功能，Tableau 设计上不返回底层物理表信息          | ❌ 无法解决               |
| **数据本身无物理来源**   | 完全由 Tableau 计算字段生成的数据，没有物理表对应               | ❌ 无需解决（本就无来源） |

**CustomSQLTable 穿透能力对比**：

```
能穿透的 SQL：
SELECT * FROM 订单表 WHERE 年份 = 2024
   ↓ Tableau 解析 SQL → 识别到 "订单表" → upstreamTables = ["订单表"]

无法穿透的 SQL：
SELECT * FROM ${动态表名} WHERE ...
   ↓ Tableau 无法识别 → upstreamTables = []
```

##### 4.4.5 穿透失败的影响

当穿透失败时的后果：

```
字段的 upstream_column_id 指向嵌入表的列
    ↓
在 db_columns 表中找不到对应记录
    ↓
无法建立完整的"三层命名"（字段名 → 物理列名 → 表名）
    ↓
血缘链路不完整
```

**当前处理策略**：
1. 保留嵌入表的 ID 作为 `table_id`（虽然不是物理表）
2. 在前端标记"来源不完整"
3. 在验证报告中记录为 WARN

**验证指标参考**：
- 穿透前：三层命名覆盖率约 10.7%
- 穿透后：三层命名覆盖率约 41.4%
- 剩余约 1,567 个字段无法建立完整血缘（受限于 Tableau API）

---

### 5. 如何找到其他元素

#### 5.1 如何找到数据表？

**查找逻辑**：在 `table_to_datasource` 表中，查找所有 `datasource_id = 当前数据源ID` 的记录，得到 `table_id` 列表。

#### 5.2 如何找到数据库？

**查找逻辑**：先找到数据表（方法如上），再读取表的 `database_id`。

#### 5.3 如何找到字段？

**查找逻辑**：在 `fields` 表中，查找所有 `datasource_id = 当前数据源ID` 的记录。

#### 5.4 如何找到工作簿？

**查找逻辑**：在 `datasource_to_workbook` 表中，查找所有 `datasource_id = 当前数据源ID` 的记录，得到 `workbook_id` 列表。

#### 5.5 如何找到上游发布源？（仅嵌入式）

**查找逻辑**：直接读取 `source_published_datasource_id` 字段。

---

### 6. 相关问题

#### 问题一：孤立工作簿（已修复）

**问题现象**：33 个工作簿没有任何数据源关联，显示"使用数据源: 0"。

**产生原因**：这些工作簿使用的是直连数据库的嵌入式数据源。之前的同步逻辑采取"一刀切"策略，所有嵌入式数据源都被丢弃，导致这类工作簿失去了数据源关联。

**解决方案**：采用"混合模式"，识别并保留"独立直连型"嵌入式数据源。

**修复效果**：
- 修复前：33 个孤立工作簿
- 修复后：0 个孤立工作簿
- 新增：47 个直连嵌入式数据源

#### 问题二：Custom SQL 血缘断裂（无法解决）

**问题现象**：使用自定义 SQL 的数据源无法追溯到物理表。

**产生原因**：Tableau API 无法解析自定义 SQL 语句，不会返回 `upstreamTables`。

**影响范围**：这类数据源的 `table_to_datasource` 为空，无法建立表→数据源的血缘。

**状态**：无法解决。

---

## 模块五：工作簿

### 1. 基本概念

**业务含义**：工作簿是 Tableau 的报表容器，一个工作簿里面包含多个视图/仪表板。

**在血缘中的位置**：上游是数据源，下游是视图。

---

### 2. 采集过程

**从哪里获取**：调用 Tableau 的工作簿列表接口，然后分批获取详情。

**调用的接口**：GraphQL 查询 `workbooks` 节点。

**获取的信息**：
- 工作簿唯一标识
- 名称、项目、所有者、创建/更新时间
- **使用的已发布数据源列表**（`upstreamDatasources`）
- **嵌入式数据源列表**（`embeddedDatasources`）及其字段
- **包含的图表列表**（`sheets`）
- **包含的仪表板列表**（`dashboards`）及其包含的图表

---

### 3. 存储方式

**存入表**：`workbooks`

**同时处理**：
- 嵌入式数据源 → 存入 `datasources`
- 视图 → 存入 `views`

---

### 4. 血缘建立

工作簿同步时建立大量关联，这是最复杂的同步步骤。

#### 4.1 `datasource_to_workbook` 关联表的建立

**处理已发布数据源**：
```
读取工作簿详情的 upstreamDatasources 列表
   ↓
例如返回：[
   {"id": "ds-001", "name": "销售数据"},
   {"id": "ds-002", "name": "用户数据"}
]
   ↓
对每个数据源：
   检查 datasource_to_workbook 表中是否已存在关联
   ↓
   如果不存在，插入关联记录：
      INSERT INTO datasource_to_workbook (datasource_id, workbook_id)
      VALUES ('ds-001', 'wb-001')
```

**处理嵌入式数据源**：
```
读取工作簿详情的 embeddedDatasources 列表
   ↓
对每个嵌入式数据源：
   ↓
   检查是否有 upstreamDatasources（判断是穿透型还是独立直连型）
   ↓
   ├─ 穿透型：
   │    将上游发布源关联到工作簿
   │    保存嵌入式数据源记录，设置 source_published_datasource_id
   │    将嵌入式源本身也关联到工作簿
   │
   └─ 独立直连型：
        保存嵌入式数据源记录（is_embedded=1）
        建立到上游表的关联
        建立到工作簿的关联
```

#### 4.2 视图与工作簿的关联

**处理图表（sheets）**：
```
遍历工作簿的 sheets 列表：
   ↓
对每个图表：
   保存到 views 表
   设置 workbook_id = 当前工作簿ID
   设置 view_type = 'sheet'
```

**处理仪表板（dashboards）**：
```
遍历工作簿的 dashboards 列表：
   ↓
对每个仪表板：
   保存到 views 表
   设置 workbook_id = 当前工作簿ID
   设置 view_type = 'dashboard'
   ↓
   同时处理仪表板包含的图表：
   遍历 dashboard.sheets 列表：
      INSERT INTO dashboard_to_sheet (dashboard_id, sheet_id)
      VALUES ('dashboard-001', 'sheet-001')
```

---

### 5. 如何找到其他元素

#### 5.1 如何找到数据源？

**查找逻辑**：在 `datasource_to_workbook` 表中，查找所有 `workbook_id = 当前工作簿ID` 的记录，得到 `datasource_id` 列表。

#### 5.2 如何找到视图？

**查找逻辑**：在 `views` 表中，查找所有 `workbook_id = 当前工作簿ID` 的记录。

#### 5.3 如何找到数据表？

**查找逻辑**：
1. 先找到数据源（方法如上）
2. 用数据源 ID 去 `table_to_datasource` 查找，得到表 ID 列表

#### 5.4 如何找到字段？

**查找逻辑**：
1. 先找到数据源
2. 在 `fields` 表中查找 `datasource_id` 在这些数据源中的记录

#### 5.5 如何找到数据库？

**查找逻辑**：先找到数据表，再读取表的 `database_id`。

---

### 6. 相关问题

工作簿模块的问题主要在数据源关联上，已在"数据源"模块说明。

---

## 模块六：视图

### 1. 基本概念

**业务含义**：视图是用户最终看到的报表页面，可以是单个图表（Sheet）或组合看板（Dashboard）。是血缘追溯的终点。

**在血缘中的位置**：上游是工作簿和字段，自身是终点。

**分类**：
- **Sheet（图表）**：单个可视化图表
- **Dashboard（仪表板）**：由多个 Sheet 组合而成

---

### 2. 采集过程

**采集时机**：在工作簿同步时一起获取。

**额外采集**：通过单独的接口获取视图使用了哪些字段（`sheetFieldInstances`）。

**获取的信息**：
- 视图唯一标识
- 名称、路径
- 视图类型（sheet/dashboard）
- 所属工作簿
- 仪表板包含的图表列表
- 访问统计（通过 REST API 另外获取）

---

### 3. 存储方式

**存入表**：`views`

**关键字段**：
- `workbook_id`：关联到所属工作簿
- `view_type`：区分 sheet 和 dashboard
- `total_view_count`：访问次数统计

---

### 4. 血缘建立

#### 4.1 视图 → 工作簿

**建立方式**：存储时直接设置 `workbook_id`。

#### 4.2 仪表板 → 包含的图表

**建立方式**：在 `dashboard_to_sheet` 关联表中插入记录。

**详细过程**：
```
处理仪表板时：
   ↓
读取仪表板的 sheets 列表（包含的图表）
   ↓
对每个图表：
   INSERT INTO dashboard_to_sheet (dashboard_id, sheet_id)
   VALUES ('dashboard-001', 'sheet-001')
```

#### 4.3 `field_to_view` 关联表的建立

这是字段与视图关联的关键！

**建立时机**：在**视图字段使用关系同步**时建立（单独的同步步骤）。

**数据来源**：Tableau API 返回的 `sheetFieldInstances`。

**详细过程**：
```
同步视图字段关联时：
   ↓
1. 先清空旧数据（全量同步策略）
   DELETE FROM field_to_view
   ↓
2. 调用接口获取所有视图使用的字段
   ↓
3. 对每个字段-视图对：
   ↓
   检查字段 ID 是否有效（可能因去重被删除）
   ↓
   ├─ 有效：直接插入
   │     INSERT INTO field_to_view (field_id, view_id)
   │     VALUES ('field-001', 'view-001')
   │
   └─ 无效（被去重）：尝试智能重连
         在工作簿关联的发布式数据源中查找同名字段
         如果找到，用新 ID 插入
```

**智能重连机制**：

因为系统做了字段去重（嵌入式字段的副本被跳过），Tableau 返回的字段 ID 可能指向已被去重的嵌入式副本。

```
字段 ID 无效时：
   ↓
获取视图所属的工作簿 ID
   ↓
查找该工作簿关联的所有发布式数据源
   ↓
在这些数据源中查找同名字段
   ↓
如果找到，用发布式字段的 ID 替代
```

---

### 5. 如何找到其他元素

#### 5.1 如何找到工作簿？

**查找逻辑**：直接读取本视图的 `workbook_id` 字段。

#### 5.2 如何找到使用的字段？

**查找逻辑**：在 `field_to_view` 表中，查找所有 `view_id = 当前视图ID` 的记录，得到 `field_id` 列表。

#### 5.3 如何找到包含的图表？（仅仪表板）

**查找逻辑**：在 `dashboard_to_sheet` 表中，查找所有 `dashboard_id = 当前仪表板ID` 的记录，得到 `sheet_id` 列表。

#### 5.4 如何找到数据源？

**查找逻辑**：
1. 先找到使用的字段（方法如上）
2. 读取这些字段的 `datasource_id`

---

### 6. 相关问题

#### 问题一：访问统计的累加

**处理逻辑**：仪表板的访问量会累加到其包含的图表上（因为用户访问仪表板时也相当于访问了这些图表）。

---

## 模块七：字段

### 1. 基本概念

**业务含义**：字段是数据源里的具体数据项，是报表人员在 Tableau 界面上看到的可拖拽元素。字段是血缘链路的核心。

**在血缘中的位置**：上游是数据源和原始列，下游是视图和计算字段。

**分类**：
- **ColumnField（列字段）**：直接映射数据库的一列
- **CalculatedField（计算字段）**：用公式算出来的
- **DatasourceField（数据源字段）**：引用其他数据源的字段
- **GroupField（分组字段）**：对某个字段进行分组

---

### 2. 采集过程

**从哪里获取**：遍历所有数据源，获取每个数据源的字段列表。

**调用的接口**：GraphQL 查询数据源下的 `fields` 节点。

**获取的信息**：
- 字段唯一标识
- 名称、数据类型、角色（维度/度量）
- 是否计算字段、公式
- **对应的原始列**（`upstreamColumns`）← 用于关联到数据表
- **依赖的字段**（计算字段的 `upstreamFields`）

---

### 3. 存储方式

**存入表**：`fields`（基本信息）、`calculated_fields`（计算字段详情）

**关键关联字段**：
- `datasource_id`：所属数据源
- `table_id`：关联的数据表
- `upstream_column_id`：对应的原始列
- `workbook_id`：所属工作簿（嵌入式字段可能有）

---

### 4. 血缘建立

字段是血缘最复杂的模块，需要建立多个关联。

#### 4.1 字段 → 数据源

**建立方式**：直接设置 `datasource_id = 数据源ID`。

**特殊处理**：如果 `datasource_id` 指向的数据源不存在（可能是嵌入式数据源被丢弃），会尝试通过 `table_id` 反向查找发布式数据源。

#### 4.2 字段 → 数据表

**建立方式**：从 `upstreamColumns[0].table` 提取表 ID，设置 `table_id`。

**详细过程**：
```
解析字段的 upstreamColumns 列表：
   ↓
取第一个原始列的 table 信息：
   ↓
检查 table.__typename（表类型）：
   ↓
├─ DatabaseTable（物理表）：
│    直接使用其 ID
│    设置字段的 table_id = table.id
│
└─ EmbeddedTable / CustomSQLTable（嵌入式/自定义 SQL）：
     需要穿透到上游物理表
     使用 table.upstreamTables[0].id
     设置字段的 table_id = upstreamTables[0].id
```

**嵌入式表穿透的代码逻辑**：
```python
def _get_physical_table_id(self, table_info):
    typename = table_info.get("__typename")
    
    if typename == "DatabaseTable":
        # 物理表，直接使用
        return table_info.get("id")
    
    # 嵌入式表或 Custom SQL 表，穿透到 upstreamTables
    upstream_tables = table_info.get("upstreamTables") or []
    if upstream_tables:
        return upstream_tables[0].get("id")
    
    return table_info.get("id")  # 无法穿透，使用原 ID
```

#### 4.3 字段 → 原始列

**建立方式**：直接设置 `upstream_column_id` 和 `upstream_column_name`。

**数据来源**：从 `upstreamColumns[0]` 获取。

#### 4.4 计算字段 → 依赖的字段

**建立时机**：在**血缘同步**时建立。

**详细过程**：
```
同步血缘时：
   ↓
1. 清空旧数据
   DELETE FROM field_dependencies
   ↓
2. 获取所有计算字段及其公式
   ↓
3. 对每个计算字段，解析公式中的字段引用：
   使用正则表达式匹配 \[(.*?)\] 提取所有 [字段名]
   例如公式 "[销售额] / [订单数]" 提取出 ["销售额", "订单数"]
   ↓
4. 对每个引用的字段名：
   ↓
   尝试匹配字段 ID：
   ├─ 先在同数据源中匹配
   │    查找 (datasource_id, 字段名) 对应的字段 ID
   │
   └─ 如果找不到，全局匹配
        查找名称匹配的任意字段
   ↓
5. 插入依赖记录：
   INSERT INTO field_dependencies 
   (source_field_id, dependency_field_id, dependency_name, dependency_type)
   VALUES ('calc-field-001', 'base-field-001', '销售额', 'formula')
```

---

### 5. 字段去重逻辑

#### 5.1 为什么要去重？

同一个字段在**已发布数据源**和**引用它的嵌入式数据源**中各存一份。如果不去重，一个字段会被保存 N+1 次。

#### 5.2 去重方式

**两阶段处理**：
```
第一阶段：处理已发布数据源的字段
   ↓
保存所有字段
建立缓存：(datasource_id, field_name) → field_id
   ↓
第二阶段：处理嵌入式数据源的字段
   ↓
检查 (datasource_id, field_name) 是否已存在于缓存
   ↓
├─ 存在：跳过（这是副本）
│
└─ 不存在：保存（这是工作簿特有的计算字段）
```

**效果**：
- 去重前：20,234 个字段
- 去重后：12,768 个字段
- 去重比例：~40%

---

### 6. 如何找到其他元素

#### 6.1 如何找到数据源？

**查找逻辑**：直接读取本字段的 `datasource_id` 字段。

#### 6.2 如何找到数据表？

**查找逻辑**：直接读取本字段的 `table_id` 字段。如果为空，可以尝试通过预计算的 `field_full_lineage` 表查询。

#### 6.3 如何找到原始列？

**查找逻辑**：直接读取本字段的 `upstream_column_id` 字段。

#### 6.4 如何找到数据库？

**查找逻辑**：
1. 先找到数据表（读取 `table_id`）
2. 再读取表的 `database_id`

#### 6.5 如何找到工作簿？

**方式一**：查 `field_full_lineage` 预计算表。

**方式二**：
1. 读取 `datasource_id`
2. 去 `datasource_to_workbook` 表查找相关的 `workbook_id`

#### 6.6 如何找到视图（被哪些视图使用）？

**查找逻辑**：在 `field_to_view` 表中，查找所有 `field_id = 当前字段ID` 的记录，得到 `view_id` 列表。

#### 6.7 如何找到引用我的计算字段？

**查找逻辑**：在 `field_dependencies` 表中，查找所有 `dependency_field_id = 当前字段ID` 的记录，得到 `source_field_id` 列表（这些就是引用我的计算字段）。

---

### 7. 相关问题

#### 问题一：孤立字段（已修复）

**问题现象**：4,634 个字段的 `datasource_id` 指向不存在的数据源 ID。

**产生原因**：嵌入式数据源被丢弃后，属于这些数据源的字段就变成了"孤儿"。

**解决方案**：采用混合模式，保留独立直连型嵌入源。

#### 问题二：计算字段物理表缺失（无法完全解决）

**问题现象**：3,807 个计算字段无法追溯到物理表，关联率仅 22.76%。

**产生原因**：
1. 计算字段本身不直接关联物理列
2. 需要通过 `upstreamFields` 间接追溯
3. 部分计算字段的 `upstreamFields` 也是计算字段，需要递归追溯

**当前处理**：尽可能通过 `upstreamFields` 追溯，如果能找到物理表就设置 `table_id`。

#### 问题三：嵌入式字段到视图关联失效（已修复）

**问题现象**：去重后，Tableau 返回的嵌入式字段 ID 已不存在于数据库。

**解决方案**：智能重连机制（详见"视图"模块的 `field_to_view` 建立过程）。

#### 问题四：物理表的列未同步（已修复）

**问题现象**：早期版本中，有 1,414 个原始字段的 `upstream_column_id` 在 `db_columns` 表中找不到对应记录。

**产生原因**：这些物理表的列没有被同步到 `db_columns` 表。可能是数据库视图，Tableau API 对视图的列采集支持有限。

**解决方案**：在字同步阶段，如果发现字段有上游列 ID 但本地无记录，会自动根据 API 返回信息创建缺失的列和表。

#### 问题五：表引用字段无关联（已修复）

**问题现象**：早期版本中，约 900 个原始字段的 `table_id` 为空，但在 Tableau UI 中可以看到其上游表。

**解决方案**：已添加补救逻辑。当字段的 `upstreamColumns` 为空时，检查字段名是否与某个已知表名匹配。如果匹配，自动关联到该表。

---

### 8. 原始字段血缘追溯完整处理逻辑

#### 8.1 原始字段追溯现状统计

| 类别              | 数量  | 占比  | 状态           |
| ----------------- | ----- | ----- | -------------- |
| A: 物理表+有效列  | 1,367 | 17.4% | ✅ 完整追溯     |
| B1: 物理表+无效列 | 1,414 | 18.0% | ⚠️ 表的列未同步 |
| C1: 嵌入表+有效列 | 3,925 | 50.1% | ✅ 追溯到嵌入表 |
| D: 无关联表       | 1,133 | 14.5% | ⚠️ 部分待修复   |

#### 8.2 正确的处理逻辑

```
┌─────────────────────────────────────────────────────────────────┐
│  1. 解析字段类型 (__typename)                                    │
├─────────────────────────────────────────────────────────────────┤
│  ├── ColumnField     → 从 upstreamColumns 获取表/列              │
│  ├── CalculatedField → 分析 formula，关联依赖字段               │
│  ├── DatasourceField → 从 remoteField 获取发布源字段            │
│  ├── GroupField      → 标记为分组字段，无需追溯物理表           │
│  └── 其他            → 检查是否为表引用                         │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. 尝试 upstreamColumns 获取上游表和列                          │
├─────────────────────────────────────────────────────────────────┤
│  有返回：                                                        │
│  ├── table.__typename = DatabaseTable → 直接使用物理表 ✅       │
│  └── table.__typename = EmbeddedTable → 穿透或使用嵌入表        │
│                                                                  │
│  无返回 → 进入补救逻辑                                           │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. 补救逻辑（当 upstreamColumns 为空）                          │
├─────────────────────────────────────────────────────────────────┤
│  ├── 检查字段名是否 = 某个已知表名                               │
│  │   └── 如果匹配，关联到该表                                   │
│  │                                                               │
│  ├── 检查字段的 datasource 的 upstreamTables                    │
│  │   └── 尝试从数据源的上游表中匹配                             │
│  │                                                               │
│  └── 无法匹配 → 标记为"无物理来源"（系统字段、分组字段等）      │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. 确保表的列同步完整                                           │
├─────────────────────────────────────────────────────────────────┤
│  ├── 同步表时，必须同步其所有列到 db_columns                     │
│  └── 如果 API 不返回列（如视图），标记为"列信息缺失"            │
└─────────────────────────────────────────────────────────────────┘
```

#### 8.3 各类型字段的追溯链路

**A 类：物理表 + 有效列（完整追溯）**
```
字段 → 物理列 (db_columns) → 物理表 (tables) → 数据库 (databases)
```

**B1 类：物理表 + 无效列（表级追溯）**
```
字段 → ??? (列缺失) → 物理表 (tables) → 数据库 (databases)
      ↑
  upstream_column_id 存在但 db_columns 中无记录
```

**C1 类：嵌入表 + 有效列（嵌入层追溯）**
```
字段 → 嵌入列 (db_columns) → 嵌入表 (tables, is_embedded=1) → 无物理数据库
      ↑
  来自 CSV/Excel/自定义SQL，本身就是数据源头
```

**D 类：无关联表**
- 系统字段（`:Measure Names`）：正常，本无来源
- 分组字段（`xx (组)`）：正常，用户自定义分桶
- 表引用字段（`日期表`）：待修复，应通过表名匹配关联

---

## 模块八：计算字段/指标

### 1. 基本概念

**业务含义**：计算字段是用户用公式创建的派生字段，比如"利润率 = 利润 / 销售额"。在治理中，角色为"度量"的计算字段通常被称为"指标"。

**在血缘中的位置**：上游是它引用的基础字段，下游是使用它的视图。

---

### 2. 采集过程

**采集时机**：在字段同步时，识别 `__typename == "CalculatedField"` 的字段。

**额外获取的信息**：
- 公式（`formula`）
- 依赖的上游字段（`upstreamFields`）

---

### 3. 存储方式

**存入表**：
- `fields`（基本信息，设置 `is_calculated = true`）
- `calculated_fields`（扩展信息，包含公式、复杂度等）

---

### 4. 血缘建立

#### 4.1 计算字段 → 依赖的基础字段

详见"字段"模块的 4.4 节。

#### 4.2 公式哈希用于重复检测

**详细过程**：
```
计算统计时：
   ↓
对每个计算字段的公式：
   标准化公式（去除空格、转小写等）
   计算 MD5 哈希值
   存入 calculated_fields.formula_hash
   ↓
查找相同哈希的记录：
   如果多于 1 条，标记 has_duplicates = true
   记录 duplicate_count = 重复数量
```

---

### 5. 如何找到其他元素

#### 5.1 如何找到依赖的基础字段？

**查找逻辑**：在 `field_dependencies` 表中，查找所有 `source_field_id = 当前计算字段ID` 的记录，得到 `dependency_field_id` 列表。

#### 5.2 如何找到相同公式的重复指标？

**查找逻辑**：在 `calculated_fields` 表中，查找所有 `formula_hash` 等于当前字段 `formula_hash` 的记录，排除自己。

---

### 6. 相关问题

#### 问题一：公式重复

**问题现象**：多个计算字段使用相同的公式。

**产生原因**：
1. 在多个数据源/工作簿中重复定义同一个指标
2. 复制工作簿时，计算字段也被复制

**检测方式**：通过 `formula_hash` 识别。

---

# 专题一：嵌入式表血缘设计详解

## 一、概述

### 1.1 什么是嵌入式表？

嵌入式表（Embedded Table）是 Tableau 中的一种特殊表类型。它不是数据库中实际存在的物理表，而是存在于数据源定义内部的"虚拟表"。

**与物理表的区别**：

| 特性               | 物理表（DatabaseTable） | 嵌入式表（EmbeddedTable/CustomSQLTable） |
| ------------------ | ----------------------- | ---------------------------------------- |
| 存在位置           | 数据库服务器            | Tableau 数据源内部                       |
| 是否持久化         | 是                      | 否（依赖数据源定义）                     |
| 可被多个数据源复用 | 是                      | 否（只属于当前数据源）                   |
| 血缘追溯           | 直接                    | 需要穿透到上游物理表                     |

### 1.2 嵌入式表的产生场景

| 场景           | 产生的表类型           | 示例                                   |
| -------------- | ---------------------- | -------------------------------------- |
| Excel/CSV 导入 | EmbeddedTable          | 用户拖入 Excel 文件                    |
| 自定义 SQL     | CustomSQLTable         | `SELECT * FROM 订单表 WHERE 年份=2024` |
| 虚拟连接       | VirtualConnectionTable | 通过 Virtual Connection 定义的表       |
| 数据混合/JOIN  | EmbeddedTable          | 多表关联后的结果集                     |
| 参数表         | EmbeddedTable          | Tableau 内部定义的参数                 |

---

## 二、血缘设计

### 2.1 嵌入式表的血缘结构

```
                      ┌─────────────────┐
                      │   数据库        │ (最上游)
                      │   Database      │
                      └────────┬────────┘
                               │
                      ┌────────▼────────┐
                      │   物理表        │
                      │   DatabaseTable │
                      └────────┬────────┘
                               │ upstreamTables (来源关系)
                      ┌────────▼────────┐
                      │   嵌入式表      │
                      │   EmbeddedTable │ (中间层)
                      │   CustomSQLTable│
                      └────────┬────────┘
                               │ columns (包含列)
                      ┌────────▼────────┐
                      │   嵌入式列      │
                      │   (在嵌入式表中)│
                      └────────┬────────┘
                               │ upstream_column_id (字段引用)
                      ┌────────▼────────┐
                      │   字段 Field    │ (下游)
                      └─────────────────┘
```

### 2.2 关键关联字段

**嵌入式表存储在 `tables` 表中**：
- `id`：表唯一标识
- `name`：表名称
- `database_id`：所属数据库（如果有）
- `is_embedded`：标记为 1

**嵌入式表到物理表的关系**：
- 通过 Tableau API 返回的 `upstreamTables` 字段获取
- 这个信息**不持久化**到数据库，而是在字段同步时用于"穿透"

### 2.3 血缘穿透机制

**为什么需要穿透？**

字段的 `upstream_column_id` 可能指向嵌入式表的列，但我们在治理时真正关心的是"数据来自哪张物理表"。

**穿透过程详解**：

```
字段同步时，处理 upstreamColumns：
   ↓
取第一个列，获取其 table 信息
   ↓
读取 table.__typename：
   ↓
├─ "DatabaseTable"
│    这是物理表，无需穿透
│    field.table_id = table.id
│
├─ "EmbeddedTable" / "CustomSQLTable"
│    这是嵌入式表，需要穿透
│    ↓
│    读取 table.upstreamTables 列表
│    ↓
│    ├─ 列表不为空
│    │    取第一个上游表：upstreamTables[0]
│    │    field.table_id = upstreamTables[0].id
│    │    ↓
│    │    (如果上游表还是嵌入式，理论上可递归穿透)
│    │
│    └─ 列表为空
│         无法穿透，血缘在此中断
│         field.table_id = table.id (或 null)
│         标记为"来源不完整"
│
└─ "VirtualConnectionTable"
     很少有 upstreamTables，通常无法穿透
```

---

## 三、与其他模块的交互

### 3.1 嵌入式表 ↔ 数据源

**关系建立**：
嵌入式表通过 `table_to_datasource` 关联表连接到嵌入式数据源。

**建立时机**：
在保存嵌入式数据源时，遍历其 `upstreamTables`，建立关联。

**异常情况**：
- 如果嵌入式数据源被丢弃，`table_to_datasource` 中的记录也会丢失
- 导致嵌入式表变成"孤立表"

### 3.2 嵌入式表 ↔ 工作簿

**间接关系**：
嵌入式表 → 嵌入式数据源 → 工作簿

**查询方式**：
```sql
SELECT DISTINCT dw.workbook_id
FROM tables t
JOIN table_to_datasource td ON t.id = td.table_id
JOIN datasource_to_workbook dw ON td.datasource_id = dw.datasource_id
WHERE t.is_embedded = 1 AND t.id = '当前嵌入式表ID'
```

**异常情况及修复**：
之前穿透型嵌入源遗漏了建立 `datasource_to_workbook` 关联，导致查询结果为空。已修复。

### 3.3 嵌入式表 ↔ 字段

**关系建立**：
字段的 `table_id` 可能直接指向嵌入式表（穿透失败时），或指向穿透后的物理表。

**字段的两种 table_id 来源**：

| 情况     | table_id 指向 | 说明             |
| -------- | ------------- | ---------------- |
| 穿透成功 | 物理表        | 能追溯到真实来源 |
| 穿透失败 | 嵌入式表      | 血缘在此中断     |

### 3.4 嵌入式表 ↔ 原始列

**嵌入式表的列存储策略**：
系统会把嵌入式表的列存入 `db_columns` 表，便于 `upstream_column_id` 的关联查询。

**问题**：
早期版本跳过了嵌入式表列的同步，导致 `upstream_column_id` 找不到对应记录。

---

## 四、异常数据处理

### 4.1 孤立嵌入式表

**现象**：嵌入式表在 `table_to_datasource` 中没有记录。

**原因**：所属的嵌入式数据源被丢弃（一刀切策略）。

**检测 SQL**：
```sql
SELECT t.id, t.name
FROM tables t
LEFT JOIN table_to_datasource td ON t.id = td.table_id
WHERE t.is_embedded = 1 AND td.datasource_id IS NULL
```

**解决**：采用混合模式，保留独立直连型嵌入源。

### 4.2 嵌入式表列 ID 不匹配

**现象**：字段的 `upstream_column_id` 在 `db_columns` 中找不到。

**原因分类及处理**：

| 原因                      | 解决方案                        |
| ------------------------- | ------------------------------- |
| 嵌入式表列未同步          | 同步时保存嵌入式表的列          |
| CustomSQLTable 列         | 尝试穿透到物理表，使用物理列 ID |
| VirtualConnectionTable 列 | 无法解决，标记 WARN             |

### 4.3 嵌入式表工作簿关联缺失

详见"模块二：数据表"的问题二。

---

# 专题二：嵌入式数据源血缘设计详解

## 一、概述

### 1.1 什么是嵌入式数据源？

嵌入式数据源（Embedded Datasource）是直接存在于工作簿内部的数据源，而不是独立发布到 Tableau Server 的已发布数据源。

**与已发布数据源的区别**：

| 特性                   | 已发布数据源           | 嵌入式数据源       |
| ---------------------- | ---------------------- | ------------------ |
| 存在位置               | Tableau Server（独立） | 工作簿内部         |
| 可被多个工作簿复用     | 是                     | 否                 |
| 在数据源列表中可见     | 是                     | 否（需进入工作簿） |
| 独立管理（权限、刷新） | 是                     | 依赖工作簿         |
| 血缘追溯               | 直接                   | 需判断穿透还是独立 |

### 1.2 嵌入式数据源的两种类型

这是理解嵌入式数据源血缘的核心！

| 类型           | 判断条件                 | 业务含义           | 处理策略           |
| -------------- | ------------------------ | ------------------ | ------------------ |
| **穿透型**     | 有 `upstreamDatasources` | 引用了已发布数据源 | 血缘穿透到已发布源 |
| **独立直连型** | 无 `upstreamDatasources` | 自己直接连接数据库 | 保存为独立实体     |

**穿透型示例**：
```
用户在工作簿中"连接"一个已发布数据源"销售数据"
   ↓
Tableau 自动生成一个嵌入式数据源作为"副本"
   ↓
这个嵌入源的 upstreamDatasources = ["销售数据"]
   ↓
我们应该把字段关联到"销售数据"而不是这个副本
```

**独立直连型示例**：
```
用户在工作簿中直接拖入一个 Excel 文件
   ↓
Tableau 生成一个嵌入式数据源
   ↓
这个嵌入源没有 upstreamDatasources（它不引用任何已发布源）
   ↓
这是一个独立的数据源，必须保存否则血缘断裂
```

---

## 二、血缘设计

### 2.1 穿透型嵌入式数据源的血缘

```
                   ┌──────────────────────┐
                   │   已发布数据源       │
                   │   Published DS       │
                   │   (真正的数据源)     │
                   └──────────┬───────────┘
                              │ source_published_datasource_id
                   ┌──────────▼───────────┐
                   │   嵌入式数据源       │
                   │   Embedded DS        │
                   │   (工作簿内的副本)   │ ← upstreamDatasources 指向上游
                   └──────────┬───────────┘
                              │ datasource_id (已改为指向发布源)
                   ┌──────────▼───────────┐
                   │   字段               │
                   │   Field              │
                   └──────────────────────┘
```

**血缘穿透逻辑**：
1. 识别嵌入源有 `upstreamDatasources`
2. 提取上游发布源 ID
3. 保存嵌入源记录，设置 `source_published_datasource_id`
4. 将嵌入源的字段关联到上游发布源（`datasource_id` = 发布源 ID）
5. 建立嵌入源到工作簿的关联

### 2.2 独立直连型嵌入式数据源的血缘

```
                   ┌──────────────────────┐
                   │   数据库             │
                   │   Database           │
                   └──────────┬───────────┘
                              │
                   ┌──────────▼───────────┐
                   │   物理表             │
                   │   Table              │
                   └──────────┬───────────┘
                              │ table_to_datasource
                   ┌──────────▼───────────┐
                   │   嵌入式数据源       │
                   │   Embedded DS        │
                   │   is_embedded = 1    │ ← 标记为嵌入式
                   └──────────┬───────────┘
                              │ datasource_to_workbook
                   ┌──────────▼───────────┐
                   │   工作簿             │
                   │   Workbook           │
                   └──────────────────────┘
```

**血缘建立逻辑**：
1. 识别嵌入源没有 `upstreamDatasources`
2. 保存嵌入源为独立实体（`is_embedded = 1`）
3. 建立嵌入源到上游表的关联（`table_to_datasource`）
4. 建立嵌入源到工作簿的关联（`datasource_to_workbook`）
5. 将嵌入源的字段保留原归属（`datasource_id` = 嵌入源 ID）

### 2.3 关键数据库字段

**datasources 表**：
- `id`：数据源唯一标识
- `name`：数据源名称
- `is_embedded`：是否嵌入式（1=是，0=否）
- `source_published_datasource_id`：穿透型嵌入源指向的上游发布源 ID
- `project_name`：项目名（嵌入式通常为 "(Embedded)"）

---

## 三、与其他模块的交互

### 3.1 嵌入式数据源 ↔ 工作簿

**关系建立**：
通过 `datasource_to_workbook` 关联表。

**两种类型的处理差异**：

| 类型       | datasource_to_workbook 记录                 |
| ---------- | ------------------------------------------- |
| 穿透型     | 插入两条：上游发布源→工作簿 + 嵌入源→工作簿 |
| 独立直连型 | 插入一条：嵌入源→工作簿                     |

**查询嵌入式数据源的工作簿**：
```sql
SELECT w.id, w.name
FROM workbooks w
JOIN datasource_to_workbook dw ON w.id = dw.workbook_id
JOIN datasources ds ON ds.id = dw.datasource_id
WHERE ds.is_embedded = 1 AND ds.id = '嵌入式数据源ID'
```

### 3.2 嵌入式数据源 ↔ 数据表

**关系建立**：
通过 `table_to_datasource` 关联表。

**穿透型**：
嵌入源不直接关联表，其上游发布源关联表。

**独立直连型**：
嵌入源直接关联上游表（从 `upstreamTables` 获取）。

**建立过程**：
```python
def _save_embedded_datasource(self, ds_data, workbook_id, source_published_ds_id=None):
    # ...保存嵌入源记录...
    
    # 建立到上游表的关联（独立直连型的关键血缘）
    upstream_tables = ds_data.get("upstreamTables", [])
    for tbl in upstream_tables:
        # INSERT INTO table_to_datasource (table_id, datasource_id)
        self._link_table_to_datasource(tbl["id"], ds_id)
```

### 3.3 嵌入式数据源 ↔ 字段

**穿透型**：
字段应该关联到上游发布源，而不是嵌入源本身。

```python
# 去重逻辑判断
if 嵌入源有上游发布源:
    字段.datasource_id = 上游发布源.id  # 穿透
else:
    字段.datasource_id = 嵌入源.id  # 保留
```

**去重策略**：
1. 先处理已发布数据源的字段，建立缓存 `(datasource_id, name) → field_id`
2. 再处理嵌入式数据源的字段，若 `(上游发布源_id, name)` 已存在则跳过
3. 这样穿透型嵌入源的字段不会重复，独立直连型的字段正常保存

### 3.4 嵌入式数据源 ↔ 已发布数据源

**关系**：穿透型嵌入源通过 `source_published_datasource_id` 指向上游发布源。

**查询嵌入源的上游发布源**：
```sql
SELECT pds.*
FROM datasources pds
WHERE pds.id = (
    SELECT eds.source_published_datasource_id
    FROM datasources eds
    WHERE eds.id = '嵌入式数据源ID'
)
```

**查询发布源有多少嵌入式副本**：
```sql
SELECT COUNT(*) 
FROM datasources eds
WHERE eds.source_published_datasource_id = '发布源ID'
```

### 3.5 嵌入式数据源 ↔ 视图

**间接关系**：
嵌入式数据源 → 字段 → 视图（通过 `field_to_view`）

**智能重连机制**：
因为字段去重后嵌入式字段可能不存在，视图关联时需要"重连"到发布源的同名字段。

---

## 四、异常数据处理

### 4.1 孤立工作簿（已修复）

**问题现象**：33 个工作簿没有数据源关联，显示"使用数据源: 0"。

**根因分析**：
这些工作簿使用的是独立直连型嵌入式数据源。之前的"一刀切"策略把所有嵌入源都丢弃了。

**解决方案**：
采用"混合模式"——保留独立直连型嵌入源。

**识别独立直连型**：
```python
if not eds.get("upstreamDatasources"):
    # 这是独立直连型，需要保存
    self._save_embedded_datasource(eds, wb_id)
```

**修复效果**：
- 修复前：33 个孤立工作簿
- 修复后：0 个孤立工作簿
- 新增：47 个独立直连型嵌入式数据源

### 4.2 孤立字段（已修复）

**问题现象**：4,634 个字段的 `datasource_id` 指向不存在的数据源。

**根因分析**：
嵌入式数据源被丢弃后，字段的 `datasource_id` 变成了"悬空指针"。

**解决方案**：
同上，保留独立直连型嵌入源后，字段有了归属。

### 4.3 嵌入式数据源到工作簿关联缺失（已修复）

**问题现象**：查询嵌入式数据源的工作簿时返回空。

**根因分析**：
穿透型嵌入源处理时，只建立了"上游发布源→工作簿"的关联，遗漏了"嵌入源本身→工作簿"的关联。

**解决方案**：
在保存穿透型嵌入源后，显式调用建立工作簿关联：
```python
self._save_embedded_datasource(eds, wb_id, source_published_ds_id=upstream_ds_id)
self._link_datasource_to_workbook(eds["id"], wb_id)  # 补齐这一步
```

### 4.4 字段重复（已修复）

**问题现象**：字段总数 20,234，明显偏高。

**根因分析**：
同一个字段在已发布数据源和引用它的嵌入式数据源中各存一份。

**解决方案**：
两阶段去重策略。

**修复效果**：
- 去重前：20,234 个字段
- 去重后：12,768 个字段
- 去重比例：~40%

### 4.5 嵌入式字段视图关联失效（已修复）

**问题现象**：字段使用统计不准，很多字段显示"被 0 个视图使用"。

**根因分析**：
Tableau API 返回的字段 ID 是嵌入式副本的 ID，但这些副本在去重时被跳过了，数据库里没有记录。

**解决方案**：
智能重连机制——根据字段名和工作簿上下文，找到对应的发布源字段 ID。

**重连逻辑**：
```python
if field_id not in valid_field_ids:
    # 字段 ID 无效，尝试重连
    workbook_datasources = wb_ds_map.get(workbook_id, [])
    for ds_id in workbook_datasources:
        key = (ds_id, field_name)
        if key in published_fields_map:
            field_id = published_fields_map[key]  # 使用发布源字段的 ID
            break
```

---

## 五、最佳实践

### 5.1 识别嵌入式数据源类型

```python
def classify_embedded_datasource(eds):
    upstream_ds = eds.get("upstreamDatasources", [])
    if upstream_ds:
        return "穿透型", upstream_ds[0]["id"]
    else:
        return "独立直连型", None
```

### 5.2 穿透型处理清单

1. ✅ 将上游发布源关联到工作簿
2. ✅ 保存嵌入源记录，设置 `source_published_datasource_id`
3. ✅ 将嵌入源本身也关联到工作簿
4. ✅ 字段归属到上游发布源
5. ✅ 字段去重（跳过与发布源同名的字段）

### 5.3 独立直连型处理清单

1. ✅ 保存嵌入源为独立实体（`is_embedded = 1`）
2. ✅ 建立嵌入源到上游表的关联
3. ✅ 建立嵌入源到工作簿的关联
4. ✅ 字段保留原归属（属于嵌入源）
5. ✅ 字段正常保存（不去重）

---

# 第三部分：问题汇总与解决方案

## 一、已修复的问题

| 问题                   | 现象                     | 原因             | 解决方案                 |
| ---------------------- | ------------------------ | ---------------- | ------------------------ |
| 孤立工作簿             | 33个工作簿没有数据源关联 | 直连嵌入源被丢弃 | 混合模式：保留独立直连源 |
| 孤立字段               | 4,634个字段无归属        | 嵌入源被丢弃     | 同上                     |
| 字段重复               | 20,234→12,768            | 嵌入式副本       | 两阶段去重               |
| 嵌入式表工作簿关联缺失 | 显示"引用工作簿:0"       | 漏建关联         | 显式调用关联建立         |
| Prefetch 404           | 前端报错                 | 孤立表引用       | API过滤+前端静默         |
| 嵌入式字段视图关联失效 | 字段使用统计不准         | 去重后ID失效     | 智能重连                 |

## 二、无法解决的问题

| 问题                     | 现象           | 原因                       | 影响                  |
| ------------------------ | -------------- | -------------------------- | --------------------- |
| Custom SQL 血缘断裂      | 无法追溯物理表 | Tableau 无法解析自定义 SQL | 3,807个字段无table_id |
| VirtualConnection 列无效 | 列ID无法匹配   | 特殊表类型                 | 1,567个字段列ID无效   |
| 计算字段物理表关联率低   | 仅22.76%       | 需要递归追溯               | 血缘不完整            |

---

# 第四部分：注意事项

## 一、同步顺序很重要

必须按依赖顺序同步，确保上游元素先入库：
```
数据库 → 数据表 → 数据源 → 工作簿 → 字段 → 视图关联 → 血缘
```

## 二、嵌入式数据源的两种类型

| 类型       | 特征                     | 处理方式           |
| ---------- | ------------------------ | ------------------ |
| 穿透型     | 有 `upstreamDatasources` | 字段归到上游发布源 |
| 独立直连型 | 无 `upstreamDatasources` | 保存为独立实体     |

## 三、字段的四层名称

| 层级       | 说明             | 示例                      |
| ---------- | ---------------- | ------------------------- |
| 原始列名   | 数据库物理列名   | `order_amount`            |
| 完全限定名 | Tableau 内部标识 | `[Orders].[Order Amount]` |
| 显示名称   | 用户界面显示名   | `订单金额`                |
| 成员别名   | 维度值替代名     | `Q1` 显示为 `第一季度`    |

## 四、提取 vs 实时模式

| 模式          | 说明     | 影响               |
| ------------- | -------- | ------------------ |
| 提取(Extract) | 定期快照 | 需监控刷新状态     |
| 实时(Live)    | 实时连接 | 每次查询都走数据库 |

---

*文档版本：5.0*  
*更新日期：2025-12-24*
